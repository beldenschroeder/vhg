# Von Herff Gallery

<a alt="Nx logo" href="https://nx.dev" target="_blank" rel="noreferrer"><img src="https://raw.githubusercontent.com/nrwl/nx/master/images/nx-logo.png" width="45"></a>

✨ **This workspace has been generated by [Nx, a Smart, fast and extensible build system.](https://nx.dev)** ✨

## Environment Configuration

The database used in this project uses Vercel's Postress database service. An example of how to set this up can be found at [How to Build a Fullstack App with Next.js, Prisma, and Vercel Postres](https://vercel.com/guides/nextjs-prisma-postgres#step-3-setup-prisma-and-create-the-database-schema). This appication hits an existing database endpoint on Vercel's database servers.

The command

```console
vercel env pull .env
```

sync's the project's _.env_ with the environment variables used on that Vercel project account.

The _schema.prisma_ file defines the schema to build the database. To do this, run

```console
pnpm exec prisma db push
```

To add data to the database tables created, you can do this via Prisma's Studio interface. Run the command

```console
pnpm exec prisma studio
```

In Prisma Studio, populate the tables with data.

If you ever need to update you Prisma schema (_schema.prisma_), you'll also need to ensure your Prisma Client (_libs/vhg/src/lib/prisma.tsx_) accounts for this change. To do that, run

```console
pnpm exec prisma generate
```

## Start the app

### Run the app on Vercel

This project is configured as a [Vercel project deployment](https://vercel.com/docs/getting-started-with-vercel/projects-deployments). Pushing changes up on any branch other than _master_ or _main_ will display a under the _Deployements_ section of Vercel's site as a _preview_ environment.

### Run app locally in development mode

To start the development server run `pnpm exec nx serve vhg`. Open your browser and navigate to http://localhost:3000/.

### Run app locally in a Docker container in production mode

Be sure to install and run [Docker Desktop](https://www.docker.com/products/docker-desktop/).

After the Docker Desktop's Deamon is running, start the app in a Docker container locally in production mode, run

```console
pnpm i
pnpm exec nx container vhg
docker run --env-file ./.env -p 3000:3000 -t beldenschroeder/vhg:1.0
```

> NOTE: If you prefer to make updates to the app, you can give a new version tag to image by updating it in _/apps/vhg/project.json_, building the project again and run the Docker image again, as shown earlier.

Open your browser and navigate to http://localhost:3000/.

## TODO: All other build options from here forward aren't working, however, given that I'll be migrating this off K8s and using ECS, all the instructions below will be replaced. For instructions on ECS build and deploy, visit the _terraform/README.md_ file.

### Run app locally using Kubernetes

#### Build app and container with Nx

After the Docker image is created, on the command line run

```console
kubectl apply -f manifests.yaml
```

Push the image to your Docker Hub account. One way to do this is to select to the "push to Hub" option in the context menu for you image listed in Docker Desktop.

Open your browser and navigate to http://localhost:80/.

> NOTE: If you prefer to make updates to the app, update _/apps/vhg/project.json_, build the project and its image using the Nx command, as described in the section **Run app locally in a Docker container in production mode**. Push the image to Docker Hub. Then, run the following imparitive command to update the image
> ```console
> kubectl set image deployment/vhg-deployment vhg=beldenschroeder/vhg:[tag]
> ```
>
> where _[tag]_ is the new tag name.

### Access the Kubernetes Dashboard

You can deploy the Von Herff Gallery to a Kubernetes cluster and manage cluster resources via the Kubernetes Dashboard. To do this, run the deploy command as explained in [Deploy and Access the Kubernetes Dashboard](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/#deploying-the-dashboard-ui).

Then, run

```console
kubectl proxy
```

Then, visit the following URL in your browser to access your Dashboard

```console
http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
```

Obtain the token for this user by running the following in your terminal

```console
kubectl version
```

If your Kubernetes server version is v1.24 or higher you must run the following command

```console
kubectl -n kubernetes-dashboard create token admin-user
```

If your Kubernetes server version is older than v1.24 you must run the following command

```console
kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath="{.secrets[0].name}") -o go-template="{{.data.token | base64decode}}"
```

Copy the token from the above output and use it to log in at the dashboard.

After a successful login, you should now be redirected to the Kubernetes Dashboard.

The above steps can be found in the official documentation:
https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md

#### Build app with Nx and container with Skaffold

Build the app by running the following Nx command:

```console
pnpm i
pnpm exec nx build vhg
```

Then, build the container and host it on Docker Hub with the following command:

```console
skaffold dev
```

Note that this generates a random container tag. You can find out what tag is by looking at the logs generated from running the `skaffold` command.

## Run app remotely using Kubernetes with GitHub Actions

Update the _.github/workflows/main.yaml_ to suite your GitHub Actions profile. Be sure that your GitHub Actions secrets are created to reflect what's in the _main.yaml_ file. The following secrets should be set as such:

```console
EKS_CLUSTER=vhg-cluster
EKS_REGION=us-east-1
```

If you choose to provide different values here, update the corresponding Terraform `.tf` files under _terraform/_.

Under _terraform/_, run

```console
terraform init
terraform plan
terraform apply
```

Run the following to build the app

```console
pnpm i
pnpm exec nx build vhg
```

Push your `main` branch up to your corresponding GitHub remote branch and GitHub Actions should build and containerize the app and provision it on AWS.

On your AWS account, visit your Load Balancer's DNS to see the running site!

## Tear down the infrastructure

### Teardown from local setup

For local runs using Kubernetes, switch to the Kubernetes context

```console
aws eks update-kubeconfig --name vhg-cluster --region us-east-1
```

Then, delete the manifests

```console
kubectl delete -f manifests.yaml
```

If you ran the Kubernetes Dashboard, use the `kubectl delete` command as well to remove any other K8s objects created.

### Teardown from remote setup

To tear down the remote setup, switch to the Kubernetes context

```console
aws eks update-kubeconfig --name vhg-cluster --region us-east-1
```

Then, delete the manifests

```console
kubectl delete -f manifests.yaml
```

Destroy all the EKS Terraform setup by going to _terraform/_ and running

```console
terraform destroy
```